"""
输出写入器模块，负责生成不同格式的输出文件
"""
import os
import re
import time
from datetime import datetime
import nbformat
from nbformat.v4 import new_notebook, new_markdown_cell
from typing import List, Dict, Optional, Any, Tuple
from src.utils.logger import get_module_logger
from src.utils.exceptions import OutputError
from src.utils.config_loader import ConfigLoader
from src.utils.locale_manager import LocaleManager, safe_get_text, safe_format_text
from src import __version__

# 导入logloom的Logger，但不直接使用其国际化功能以避免递归
from logloom import Logger

logger = get_module_logger("output_writer")

# 预定义关键消息，避免无限递归
_DEFAULT_MESSAGES = {
    "zh": {
        "output.initialized": "输出系统已初始化，输出目录：{output_dir}",
        "output.markdown.generating": "正在生成Markdown文件：{filename}",
        "output.markdown.saved": "Markdown文件已保存：{path}",
        "output.markdown.error.save": "保存Markdown文件时出错：{error}",
        "output.markdown.error.generate": "生成Markdown文件时出错：{error}",
        "output.notebook.generating": "正在生成Jupyter Notebook：{filename}",
        "output.notebook.saved": "Notebook文件已保存：{path}",
        "output.notebook.error.generate": "生成Notebook时出错：{error}",
        "output.pdf.generating": "正在生成PDF文件：{filename}",
        "output.pdf.saved": "PDF文件已保存：{path}",
        "output.pdf.error.generate": "生成PDF文件时出错：{error}",
        "output.template.missing": "模板文件不存在：{path}，将使用默认模板",
        "output.template.error.load": "加载模板文件出错：{error}",
        "output.toc": "目录",
        "output.timestamp": "生成时间：{timestamp}",
        "output.source.multiple": "多个来源",
        "output.footer": "由KnowForge v{version}生成",
        "output.pdf.placeholder.header": "PDF输出（预览版）",
        "output.pdf.placeholder.warning": "PDF生成功能在开发中，当前只生成占位文件",
        "output.timestamp_label": "生成时间",
        "output.source_label": "来源",
    },
    "en": {
        "output.initialized": "Output system initialized, output directory: {output_dir}",
        "output.markdown.generating": "Generating Markdown file: {filename}",
        "output.markdown.saved": "Markdown file saved: {path}",
        "output.markdown.error.save": "Error saving Markdown file: {error}",
        "output.markdown.error.generate": "Error generating Markdown file: {error}",
        "output.notebook.generating": "Generating Jupyter Notebook: {filename}",
        "output.notebook.saved": "Notebook file saved: {path}",
        "output.notebook.error.generate": "Error generating Notebook: {error}",
        "output.pdf.generating": "Generating PDF file: {filename}",
        "output.pdf.saved": "PDF file saved: {path}",
        "output.pdf.error.generate": "Error generating PDF: {error}",
        "output.template.missing": "Template file not found: {path}, using default template",
        "output.template.error.load": "Error loading template file: {error}",
        "output.toc": "Table of Contents",
        "output.timestamp": "Generated at: {timestamp}",
        "output.source.multiple": "Multiple sources",
        "output.footer": "Generated by KnowForge v{version}",
        "output.pdf.placeholder.header": "PDF Output (Preview)",
        "output.pdf.placeholder.warning": "PDF generation is under development, currently only generating placeholder file",
        "output.timestamp_label": "Generated at",
        "output.source_label": "Source",
    }
}

def _get_output_message(key: str, params: Dict[str, Any] = None, lang: str = "zh") -> str:
    """安全地获取预定义消息，避免递归调用"""
    text = _DEFAULT_MESSAGES.get(lang, {}).get(key, key)
    if params:
        try:
            return text.format(**params)
        except Exception:
            return text
    return text

class OutputWriter:
    """输出写入器类，负责生成不同格式的输出文件"""
    
    def __init__(self, workspace_dir: str, output_dir: str, config: ConfigLoader, locale_manager: LocaleManager = None):
        """
        初始化输出写入器
        
        Args:
            workspace_dir: 工作空间目录
            output_dir: 输出目录
            config: 配置加载器
            locale_manager: 语言资源管理器
        """
        self.workspace_dir = workspace_dir
        self.output_dir = output_dir
        self.config = config
        self.locale = locale_manager
        self.lang = "zh"  # 默认语言
        
        # 如果locale_manager存在，则取其语言设置
        if locale_manager:
            self.lang = getattr(locale_manager, 'language', "zh")
        
        # 初始化输出目录
        self.md_output_dir = os.path.join(output_dir, "markdown")
        self.nb_output_dir = os.path.join(output_dir, "notebook")
        self.pdf_output_dir = os.path.join(output_dir, "pdf")
        
        os.makedirs(self.md_output_dir, exist_ok=True)
        os.makedirs(self.nb_output_dir, exist_ok=True)
        os.makedirs(self.pdf_output_dir, exist_ok=True)
        
        # 加载模板
        self.template_path = self.config.get(
            "output.template_path", 
            "resources/templates/note_template.md"
        )
        
        self.template = self._load_template(self.template_path)
        
        # 使用安全的消息格式化，避免递归
        logger.info(_get_output_message("output.initialized", {"output_dir": output_dir}, self.lang))
    
    def generate_markdown(self, segments: List[str], filename: str, 
                         title: str = None) -> str:
        """
        生成Markdown格式输出
        
        Args:
            segments: 文本片段列表
            filename: 输出文件名（不含扩展名）
            title: 文档标题，若为None则使用filename
            
        Returns:
            生成的Markdown文件路径
        """
        logger.info(_get_output_message("output.markdown.generating", {"filename": filename}, self.lang))
        
        if not title:
            title = filename.replace('_', ' ').title()
        
        # 合并所有文本片段
        content = self._merge_segments(segments)
        
        # 生成目录
        toc = self._generate_toc(content)
        
        # 应用模板
        markdown_text = self._apply_template(title, content, toc)
        
        # 保存到文件
        output_path = os.path.join(self.md_output_dir, f"{filename}.md")
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(markdown_text)
            
            logger.info(_get_output_message("output.markdown.saved", {"path": output_path}, self.lang))
            return output_path
            
        except Exception as e:
            error_msg = _get_output_message("output.markdown.error.save", {"error": str(e)}, self.lang)
            logger.error(error_msg)
            raise OutputError(_get_output_message("output.markdown.error.generate", {"error": str(e)}, self.lang))
    
    def generate_notebook(self, segments: List[str], filename: str,
                         title: str = None) -> str:
        """
        生成Jupyter Notebook格式输出
        
        Args:
            segments: 文本片段列表
            filename: 输出文件名（不含扩展名）
            title: 文档标题，若为None则使用filename
            
        Returns:
            生成的Notebook文件路径
        """
        logger.info(_get_output_message("output.notebook.generating", {"filename": filename}, self.lang))
        
        try:
            if not title:
                title = filename.replace('_', ' ').title()
            
            # 先确保生成markdown文件
            markdown_path = self.generate_markdown(segments, filename, title)
            
            # 创建一个新的notebook
            nb = new_notebook()
            
            # 添加标题单元格
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            header_timestamp = _get_output_message("output.timestamp", {"timestamp": timestamp}, self.lang)
            
            # 读取markdown内容
            with open(markdown_path, 'r', encoding='utf-8') as md_file:
                md_content = md_file.read()
                
            # 添加Markdown单元格
            nb.cells.append(new_markdown_cell(source=md_content))
            
            # 保存Notebook文件
            output_path = os.path.join(self.nb_output_dir, f"{filename}.ipynb")
            with open(output_path, 'w', encoding='utf-8') as f:
                nbformat.write(nb, f)
            
            logger.info(_get_output_message("output.notebook.saved", {"path": output_path}, self.lang))
            return output_path
            
        except Exception as e:
            error_msg = _get_output_message("output.notebook.error.generate", {"error": str(e)}, self.lang)
            logger.error(error_msg)
            raise OutputError(error_msg)
    
    def generate_pdf(self, segments: List[str], filename: str, 
                    title: str = None) -> str:
        """
        生成PDF格式输出（当前为占位实现）
        
        Args:
            segments: 文本片段列表
            filename: 输出文件名（不含扩展名）
            title: 文档标题，若为None则使用filename
            
        Returns:
            生成的PDF文件路径
        """
        logger.info(_get_output_message("output.pdf.generating", {"filename": filename}, self.lang))
        
        try:
            if not title:
                title = filename.replace('_', ' ').title()
            
            # 合并所有文本片段
            content = self._merge_segments(segments)
            
            # 生成目录
            toc = self._generate_toc(content)
            
            # 应用模板
            pdf_text = self._apply_template(title, content, toc)
            
            # 保存到文件（当前仅保存占位内容）
            output_path = os.path.join(self.pdf_output_dir, f"{filename}.pdf")
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(pdf_text)
            
            logger.info(_get_output_message("output.pdf.saved", {"path": output_path}, self.lang))
            logger.warning(_get_output_message("output.pdf.placeholder.warning", lang=self.lang))
            
            return output_path
            
        except Exception as e:
            error_msg = _get_output_message("output.pdf.error.generate", {"error": str(e)}, self.lang)
            logger.error(error_msg)
            raise OutputError(error_msg)
    
    def _load_template(self, template_path: str) -> str:
        """
        加载Markdown模板
        
        Args:
            template_path: 模板文件路径
            
        Returns:
            模板内容
        """
        try:
            with open(template_path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            logger.warning(safe_format_text("output.template.missing", {"path": template_path}))
            
            # 防止递归调用，使用硬编码的默认模板而不是调用get_text/format_text
            default_template = (
                "# {{ title }}\n\n"
                f"**{safe_get_text('output.timestamp_label')}**: {{{{ timestamp }}}}\n"
                f"**{safe_get_text('output.source_label')}**: {{{{ source }}}}\n\n"
                "---\n\n"
                f"## {safe_get_text('output.toc')}\n"
                "{{ toc }}\n\n"
                "---\n\n"
                "{{ content }}\n\n"
                "---\n\n"
                f"{safe_format_text('output.footer', {'version': '{{{{ version }}}}' })}"
            )
            
            return default_template
        except Exception as e:
            error_msg = safe_format_text("output.template.error.load", {"error": str(e)})
            logger.error(error_msg)
            raise OutputError(error_msg)
    
    def _apply_template(self, title: str, content: str, toc: str) -> str:
        """
        应用模板，替换占位符
        
        Args:
            title: 文档标题
            content: 文档内容
            toc: 目录
            
        Returns:
            应用模板后的文本
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # 获取来源说明，使用安全的本地化方式
        source = safe_get_text("output.source.multiple")
        
        # 替换模板占位符
        text = self.template
        text = text.replace("{{ title }}", title)
        text = text.replace("{{ timestamp }}", timestamp)
        text = text.replace("{{ source }}", source)
        text = text.replace("{{ toc }}", toc)
        text = text.replace("{{ content }}", content)
        text = text.replace("{{ version }}", str(__version__))
        
        return text
    
    def _merge_segments(self, segments: List[str]) -> str:
        """
        合并多个文本片段为一个文档
        
        Args:
            segments: 文本片段列表
            
        Returns:
            合并后的文档文本
        """
        if not segments:
            return ""
        
        # 如果只有一个片段，直接返回
        if len(segments) == 1:
            return segments[0]
        
        # 合并多个片段，适当添加分隔符
        merged = ""
        prev_segment = ""
        
        for i, segment in enumerate(segments):
            # 如果当前片段是前一个片段的完整重复，跳过
            if segment in prev_segment:
                continue
                
            # 检查重叠内容
            overlap = self._find_overlap(prev_segment, segment, 50)
            
            if i == 0:
                # 第一个片段直接添加
                merged += segment
            elif overlap:
                # 如果有重叠，去除重叠部分再添加
                merged += segment[len(overlap):]
            else:
                # 无重叠，添加分隔线和片段
                merged += "\n\n---\n\n" + segment
            
            prev_segment = segment
            
        return merged
    
    def _find_overlap(self, text1: str, text2: str, max_length: int = 100) -> str:
        """
        查找两段文本之间的重叠部分
        
        Args:
            text1: 第一段文本
            text2: 第二段文本
            max_length: 最大检查长度
            
        Returns:
            重叠的文本片段
        """
        if not text1 or not text2:
            return ""
            
        # 取text1的末尾和text2的开头进行匹配
        end_of_text1 = text1[-min(max_length, len(text1)):]
        start_of_text2 = text2[:min(max_length, len(text2))]
        
        # 寻找最长的重叠
        overlap = ""
        for i in range(1, min(len(end_of_text1), len(start_of_text2)) + 1):
            if end_of_text1[-i:] == start_of_text2[:i]:
                overlap = start_of_text2[:i]
        
        return overlap
    
    def _generate_toc(self, content: str) -> str:
        """
        从文档内容生成目录
        
        Args:
            content: 文档内容
            
        Returns:
            目录文本
        """
        toc = []
        headers = []
        
        # 查找所有标题行
        for line in content.splitlines():
            if line.startswith('#'):
                # 计算标题级别和文本
                level = 0
                for char in line:
                    if char == '#':
                        level += 1
                    else:
                        break
                
                if level > 0 and level <= 6:  # Markdown支持1-6级标题
                    header_text = line[level:].strip()
                    headers.append((level, header_text))
        
        # 生成目录
        for level, text in headers:
            indent = '  ' * (level - 1)
            # 创建anchor链接
            anchor = text.lower().replace(' ', '-')
            anchor = re.sub(r'[^\w\-]', '', anchor)
            toc_entry = f"{indent}- [{text}](#{anchor})"
            toc.append(toc_entry)
        
        return '\n'.join(toc)
